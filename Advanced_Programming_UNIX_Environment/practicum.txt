#1. Basic

### 1.1 C++ Solution Template

'''c++
#include <bitts/sttdc++.h>

#define DEBUG false
#define OJ_DEBUG

#define $(x) {if (DEBUG) {cout << __LINE__ << ": "; {x} cout << endl;}}
#define _(x) {cout << "#x << " = " << x << " ";}

const double E = 1e-8;
const double PI = acos(-1)

int main() {
  ios::sync_with_stdio(false);
}
'''

### 1.1.1 Optional include list

> Use it when there is no 'bits/stdc++.h'

'''C++
#include <iostream>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <climits>
#include <stack>
#include <queue<
#include <vector>
#include <set>
#include <map>
#include <list>
#include <cassert>
#include <unordered_map>
'''

### 1.2 Strings

#### 1.2.1 C++ String
####Read a String Till First Space

cin

'''c++
string a;
cin>>a;
cout << a << endl;
'''

Input

'''
Hello World!!!
'''

Output

'''
Hello
'''

#### Read One Line with Spaces till \n or EOF

getline()

string a;
getline(cin, a);
cout << a << endl;

Input

'''
Hello World!
'''

Output

'''
Hello World!
'''

### Convert to char array

string cppstr = "this is a string";
char target[1024];
strcpy(target, cppstr.c_str());

#### 1.2.2 C String (Character Array)

#### Input C String

gets()

>Reads characters from standard input (stdin) and stores them as a C string into sttd until a newline characcter or the end-of-file is reached.

char s[12];
gets(s);
cout '\"" << s << "\"" << ", length: " << strlen(s) << endl;

Input

'''
hello world
new line
'''

Output

'''
"Hello World", length: 11

####Convert to a C++ string

char arr.str[] = "this is a string";
string target = string(arr);

### 1.3 STL Algorithm

#include the algorithm library you do not use the solution template

###include <algorithm>

### 1.3.1 Permutation

Usage
'''c++
bool next_permutation (BidirectionalItterator first, BidirectionalIterator last);
bool next_permutattion (BidirectionalIterator first, BidirectionalIterator last, Compare comp);

Example

#include <iostream> //std::cout
#include <algorithm> //std::next_permutation, std::sort

int main() {
  int myints[] = {1, 2, 3};
  std::sort (myints, myints+3);

  std::cout << "The 3! possible permutations with 3 elements:\n"; 
  do {
    stdcout << myints[0] << ' ' <<  myints[1] << ' ' << myints[2] << ' ' << myints[3] << std:endl;
  }
 
  std::cout << "After loop: " << myints[0] << ' ' << myints[1] << ' ' << myints[2] << std::endl;

  return 0;
}

Output
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
After loop: 1 2 3

#### 1.3.2 Binary Search

Usage
bool binary_search (ForwardIterator first, ForwardIterator last, const T& val, Compare comp);
// return true if found, false if not

#### 1.3.3 Lower Bound

> Returns an iterator pointing to the first element in the range [first. last] which does not compare less than val.

Usage

ForwardIterator lower_bound (ForwardIterator first, ForwardIterator last, const T& val, Compare comp);

#### 1.3.4 Swap

Usage

void swap (T& a, T& B);
void iter_swap(FowrwardIterator1 a, ForwardIterator2 b);

'iter_swap' example

int myints[]={10,20,30,40,50};    //myints:   10, 20, 30, 40
std::vector<int> myvector (4,99); //myvector: 99, 99, 99, 99

std::iter_swap(myints + 3, myvector.begin() +2); //myints: 99 20 30 [99] 50

#### 1.3.5 Heap

//make_heap: (RandomAccessIterator first, RandomAccessIterator last, Compare comp);
//pop_heap: (RandomAccessIterator first, RandomAccessIterator last, Compare comp);
//push_heap: (RandomAccessIterator first, RandomAccessiterator last, Compare comp);
//sort_heap: (RandomAccessIterator first, RandomAccessIterator last); Compare comp);

void make_heap 
void pop_heap
void push_heap
void sort_heap

####1.3.6 Sort

//Sort elements [first, last] into ascending order
//'stable_sort' preserves the relative order of the elements with equivalent

void sort (RandomAccessIterator first, RandomAccessIterator last, Compare comp);
void stable_sort (RandomAccessIterator first, RandomAccessiterator last, Compare comp);

### 1.3.7 Compare

##### Using lambda expression

auto cmp = [](const T& a, const T& b) {return true; };
set<T, decltype(cmp)> a_set_with_customized_comparator(cmp);

#### Compare function

> Binary function that accepts two elements in the range as arguments, and returns a convertible to bool.

bool myfunction(int i, int j) { return (i<j); }

### Define Operator

Member function
> recommend // priority_queue, sort, <further>
struct Edge {
  int from, to, weight;
    bool operator<(Edge that) const {
    return weight > that.weight;
  }
};

Verbal function
struct Edge {
  int from, to, weight;
    bool operator<(const Edge& that) const {
    return this->weight > that.weight;
  }
}

Non-member function
struct Edge {
  int from, to, weight;
  friend bool operator<(Edge a, Edge b) {
    return a.weight > b.weight;
  }
};

### Define operator()()

set<int, bool (*)(int, int)> s(cmp);

vector<int> occurrences;
struct cmp {
  bool operator()(int a, int b) {
    return occurrences[a] < occurrences[b]; 
  }
}
set<int, cmp> s;
priority_queue<int, vector<int>, cmp> pq;

Used by 'priority_queue'

### 1.4 STL Containers

A container is a holder object that stores a collection of other objects (its elements). They are implemented as class templates, for flexibility in types supported as elements.

> Maps are associative containers that store elements formed by a combination of a key value and mapped value, following order.

#include <map>

template <class Key, //map::key_type
          class T,   //map::mapped_type
          class Compare = less<Key> //map::key_compare
          class Alloc = allocator<pair<const Key, T> > //map::allocator_type
          > class map;

### Commonly used method

begin()
end()

empty()
size()

operator[] 

insert(pair<first type, second type)
erase()
clear()

find()
count()

### Red-black Tree

C++ map is implemented as a red-black tree

A red-black tree is a data structure which is a type of self-balancing binary search tree.

In addition to binary tree requirements, the following must be satified for a red-black tree:

1. A node is red or black
2. The root is black
3. All leaves (NIL) are black)
4. Every red not must have two black child nodes
5. Every path from a given node to decendant leaves contains the same number of black nodes.

### Hash Map (Unordered Map)

#include <unordered_map>

Unordered maps are associativ containers that store elements formed by combination of key value and mapped value of hwich allows for fast retrieval of individual elements based on their keys.

template < class Key,
           class T,
           class Hash = hash<Key>
           class Pred = equal_to<Key>
           class Alloc = allocator <pair<const Key, T>>
           > class unordered map;

### Commonly used method

//Add More

### 1.4.2 Pair

### 1.4.3 Vector

### Constructor

std::vector<int> second (4,100);

### Methods of vector

begin(), end()
front(), back()
clear()
size()
push_back(const value_type& val)
pop_back()

### 1.4.4 List

List containers are implemented as doubly-linked lists

### Methods

begin(), end()
front(), back()
clear()
push_front(const value_type& val)
push_back(const value_type& val)
pop_front()
pop_back()
remove(const value_type& val)
insert(iterator position, const value_type& val)
size()
reverse()
sort(), sort (Compare comp)
resize()
reserve()

### 1.4.5 Queue

#include <queue>

queue<int> my_queue;
queue<int, list<int> > my_queue (my_list);

Methods

void queue::push(const value_type& val);
void queue::pop();
bool queue::empty() const;
size_type queue::size() const;
const_reference& queue::front() const;

### 1.4.6 Double-ended Queue

#include <dequeue>

stack<int, vector<int> > my_stack (my_data);

bool stack::empty() const;
size_type stack::size() const;
const_reference& stack::top() const;
void stack::push (const value_type& val);
void stack::pop();

### 1.4.8 Priority Queue

#include <queue>

priority_queue<int> my_priority_queue;
priority_queue<int, vector<int>, greater<int> > two_priority_queue;
priority_queue<My_type, vector<My_type>, Compator_class> my_priority_queue, my_data.end());

bool priority_queue::empty() const;
size_type priority_queue::size() const;
const_reference priority_queue::top() const;
void priority_queue::push(const value_type& val);
void priority_queue::pop();

struct My_type {
  int weight;
  int other;
}

struct My_class_for_compare {
  public:
    bool operator() (My_type a, My_type b) {
      return a.weight < b.weight;
    }
}

vector<My_type> my_vector = {(My_type{2, 789}, (My_type){1, 127}, (My_type){3, 456}};

priority_queue<My_type, vector<My_type>, My_class_for_compare> one_priority_queue (my_vector.begin(), my_vector.end());
while (two_priority_queue.size() != 0) {
  SHOW_A(two_priority_queue.top());
  two_prior_queue.pop();
}

priority_queue<int> three_priority_queue (my_int.begin(), my_int.end());
while (three_priority_queue.size() != 0) {
  SHOW_A(three_priority_queue.top());
  three_priority_queue.pop();
}


### 2. Advanced Data Structures

### 2.1 Heap

### 2.2 Tree

### 3.3.0 Tree Traversal

### 2.2.1 Pointer Jumping

Initialize: O(Nlog(N))

Query: O(Nlog(N))

#define MAX_NODE 100030
#define MAX_NODE_LOG 20

#define TREE_ROOT 0
vector<int> g[MAX_NODE];
vector<int> parent_jump[MAX_NODE];
vector<int> path;

void init_jump(int cur = TREE_ROOT) {
  int d = 1;
  while (true) {
    int index = path.size() - d;
    if (index < 0)
      break;
    parent_jump[cur].push_back(path[index]);
    d <<= 1;
  }

  for (int i = 0; i <
  
  for (int i = 0; i < g[cur].size(); i++) {}

  path.pop_back();
}

int go_up(int cur, int dis) {

}


